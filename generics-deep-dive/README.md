# Generics Deep Dive Recipe

This recipe explores more advanced concepts and nuances of Java Generics, building upon the fundamentals.

## Advanced Concepts

*   **Bounds Revisited (`extends` & `super`)**: Understanding the PECS principle (Producer Extends, Consumer Super) is crucial for designing flexible generic APIs, especially with collections.
    *   Use `? extends T` when you only *get* values from a structure (it produces `T`s).
    *   Use `? super T` when you only *put* values into a structure (it consumes `T`s).
    *   Use a specific type `T` when you need to both get and put.

*   **Intersection Types**: Using the `&` symbol in type parameter bounds allows you to specify that a type must be a subtype of multiple types (typically one class and multiple interfaces).
    ```java
    // T must be a Number AND implement Serializable & Comparable
    public <T extends Number & Serializable & Comparable<T>> void processIntersected(T value) { /*...*/ }
    ```

*   **Raw Types**: Using a generic type without its type arguments (e.g., `List` instead of `List<String>`). Raw types exist primarily for backward compatibility with pre-generics code. **Avoid using raw types in new code.** They eliminate the safety benefits of generics and can lead to runtime `ClassCastException`s.

*   **Generics and Arrays**: Creating arrays of parameterized types (e.g., `new List<String>[10]`) is **not allowed** due to type erasure conflicting with array's runtime type enforcement. You can declare arrays of generic types (`List<String>[] lists`), but cannot directly instantiate them without potentially unsafe casts or workarounds like using `List<?>[]` or raw types (which should be avoided).

*   **Wildcard Capture**: A mechanism where the compiler infers the specific unknown type represented by a wildcard (`?`) in certain contexts, allowing operations that might otherwise seem unsafe. This often happens implicitly in helper methods.

*   **Self-Referential Types (Recursive Type Bounds)**: Used when a type parameter needs to refer to the type being defined, often seen with `Comparable` or builders.
    ```java
    // Enum constants must be comparable to other constants of the SAME enum type
    public abstract class Enum<E extends Enum<E>> implements Comparable<E> { /*...*/ }

    // Builder pattern allowing method chaining in subclasses
    public abstract class Builder<B extends Builder<B>> {
        public B setFoo(String foo) { /*...*/ return self(); }
        protected abstract B self(); // Subclass returns 'this'
    }
    public class ConcreteBuilder extends Builder<ConcreteBuilder> {
        @Override protected ConcreteBuilder self() { return this; }
    }
    ```

*   **Type Inference (`<>` - Diamond Operator)**: Since Java 7, the compiler can often infer type arguments in constructor calls, reducing verbosity: `List<String> list = new ArrayList<>();` (instead of `new ArrayList<String>()`). Java continues to improve type inference in later versions, especially around lambdas and generic methods.

## Type Erasure Details

*   The compiler replaces type parameters with their bounds (or `Object` if unbounded).
*   Bridge methods may be generated by the compiler to maintain polymorphism with inherited methods that have different signatures after erasure.
*   Casts may be inserted by the compiler where necessary (e.g., when retrieving an element from a `List` after erasure).
*   This means you cannot perform certain operations involving generic types at runtime:
    *   `instanceof T` (use `instanceof SpecificType` or bounded wildcards)
    *   `new T()` (pass a `Class<T>` object or use supplier functions)
    *   `new T[10]` (use `Collection<T>` or workarounds with `Object[]` and casts)
    *   Cannot have static fields of type parameter type `T`.
    *   Cannot catch or throw objects of a generic class parameterized with a type parameter (`catch (T e)` is illegal, though `catch (SpecificException<String> e)` might be okay if `SpecificException` is generic).

Understanding these deeper aspects allows for writing more robust, flexible, and correct generic code in Java. 