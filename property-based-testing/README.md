# Property-Based Testing Recipe

Property-based testing is a testing technique where instead of writing tests for specific example inputs and expected outputs, you define general properties that your code should satisfy for *any* valid input. A property-based testing framework then generates a large number of random inputs to check if these properties hold true.

## Example-Based vs. Property-Based Testing

*   **Example-Based (e.g., standard JUnit)**: You manually select specific inputs and assert the expected output for each.
    *   Pro: Easy to understand, good for specific edge cases.
    *   Con: Might miss unexpected edge cases; requires manually thinking of all relevant examples.
    ```java
    @Test
    void testAddition() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));
        assertEquals(0, calc.add(0, 0));
        assertEquals(-2, calc.add(-5, 3));
    }
    ```
*   **Property-Based**: You define properties (rules) that should always be true for any valid input generated by the framework.
    *   Pro: Can find edge cases you didn't think of; tests a wider range of inputs automatically.
    *   Con: Requires thinking about general properties instead of specific examples; might require defining input generators.
    ```java
    // Using jqwik library (conceptual)
    @Property
    void additionIsCommutative(@ForAll int a, @ForAll int b) {
        Calculator calc = new Calculator();
        assertEquals(calc.add(a, b), calc.add(b, a));
    }
    ```

## Key Concepts

*   **Properties**: Statements about the code that should hold true for all valid inputs.
*   **Generators / Arbitraries**: Components responsible for generating random (or sometimes exhaustive) input data according to specified types or constraints.
*   **Shrinking**: When a property fails for a generated input, the framework attempts to find a *smaller* or *simpler* input that still causes the failure. This makes debugging much easier.
*   **Test Framework Integration**: Property-based testing libraries often integrate with standard test runners like JUnit 5.

## Popular Java Libraries

*   **jqwik**: A popular, standalone property-based testing framework for Java, designed with JUnit 5 integration in mind.
*   **junit-quickcheck**: Another library that integrates property-based testing concepts with JUnit 4 and 5.
*   **ScalaCheck**: While a Scala library, it heavily influenced the concept and other libraries. Sometimes used in mixed Scala/Java projects.

## Workflow (Conceptual with jqwik)

1.  **Add Dependency**: Include the chosen library (e.g., `net.jqwik:jqwik`).
2.  **Write Property Method**: Create a test method annotated with the library's annotation (e.g., `@Property` for jqwik).
3.  **Define Input Parameters**: Annotate method parameters with annotations like `@ForAll` to indicate they should be generated.
4.  **Specify Constraints (Optional)**: Use library features to constrain the generated values (e.g., `@ForAll @Positive int`, `@ForAll("positiveNumbers")`).
5.  **Assert Property**: Use standard assertion methods (like JUnit's `assertEquals`, `assertTrue`) within the property method to check if the property holds for the generated inputs.

```java
// Requires jqwik dependency and JUnit 5 platform runner
import net.jqwik.api.*;
import static org.junit.jupiter.api.Assertions.*;

class StringProperties {

    @Property // jqwik annotation
    void concatenationLength(@ForAll String s1, @ForAll String s2) {
        String concatenated = s1 + s2;
        assertEquals(s1.length() + s2.length(), concatenated.length());
    }

    @Property
    void reverseTwiceIsOriginal(@ForAll String original) {
        String reversed = new StringBuilder(original).reverse().toString();
        String reversedAgain = new StringBuilder(reversed).reverse().toString();
        assertEquals(original, reversedAgain);
    }
}
```

If jqwik finds a failing case for `concatenationLength` (e.g., due to Unicode surrogate pairs if the length calculation was naive, though standard `length()` is usually correct), it would try to shrink `s1` and `s2` to the simplest possible strings that still demonstrate the failure.

Property-based testing complements example-based testing by exploring a much larger input space automatically, often uncovering subtle bugs related to edge cases or interactions between parameters. 